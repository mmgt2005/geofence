<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geofence App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.js"></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.css" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { width: 100%; height: 100%; }
        .mapboxgl-ctrl-directions {
            top: 1rem; left: 1rem; right: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -2px rgba(0,0,0,0.1);
        }
        .mapbox-directions-step-active {
            background-color:#007cbf!important; color:white!important; font-weight:800;
        }
    </style>
</head>
<body class="flex flex-col h-screen">
    <div id="map" class="flex-1"></div>
    <div class="p-4 bg-gray-900 text-white shadow-lg z-10 flex flex-col sm:flex-row items-center justify-between rounded-t-xl">
        <div class="flex-1 mr-12">
            <p id="message" class="text-xl font-bold mb-1">Please grant location permission to start...</p>
            <p id="distance-info" class="text-xs text-green-400 hidden mb-1"></p>
            <p id="job-message" class="text-xs text-gray-400 hidden"></p>
        </div>
        <div class="flex items-center space-x-3 mt-2 sm:mt-0">
            <button id="arrived-button" class="bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-green-600 transition-colors hidden">Job Complete</button>
            <button id="voice-button" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-blue-600 transition-colors">üó£Ô∏è</button>
        </div>
    </div>

    <script>
        console.log('Starting geofence app...');
        
        // Basic variables
        mapboxgl.accessToken = 'pk.eyJ1IjoibW1ndDIwMDUiLCJhIjoiY21laW4xY2dqMDQ1NDJpcHdqOW1hMDk3ZCJ9.aSTR_k5xhzGJNPPAVAFnlw';
        const WEBHOOK_URL = 'https://go.glideapps.com/api/container/plugin/webhook-trigger/LPCunXsYkOiRLSxXBhSH/5322e093-74bf-4793-92fa-ef5713bf8ab1';

        let map, vehicleMarker, geofence, directions;
        let isInsideGeofence = false, jobTitle, geofenceLocation;
        let isInitialLoad = true, speechActive = false, directionsReady = false;
        let currentRoute = null;
        
        // Speech variables - improved duplicate prevention
        let isMobileDevice = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let recentlySpoken = new Map();
        const SPEECH_COOLDOWN = 8000;
        
        // Navigation variables - UPDATED TO 1000 FEET
        const INSTRUCTION_TRIGGER_DISTANCE = 1000;
        let routeSteps = [];
        let currentStepIndex = 0;
        let lastUserLocation = null;
        let distanceCheckInterval = null;
        let firstInstructionSpoken = false;

        console.log('Variables initialized, mobile:', isMobileDevice);

        function getUrlParams() {
            const params = {};
            new URLSearchParams(window.location.search).forEach((value, key) => {
                params[key] = (key === 'lat' || key === 'lon' || key === 'radius') ? parseFloat(value) : value;
            });
            return params;
        }

        async function sendWebhook(status,email,latitude,longitude){
            if(!WEBHOOK_URL) {
                console.error('No webhook URL configured');
                return false;
            }
            
            const data = {
                status: status,
                latitude: latitude,
                longitude: longitude,
                email: email,
                job: jobTitle || 'Unknown Job',
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                isMobile: isMobileDevice
            };
            
            console.log('Sending webhook:', status, 'to:', WEBHOOK_URL);
            console.log('Data:', JSON.stringify(data, null, 2));
            
            // Try up to 3 times with increasing timeouts
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    console.log(`Webhook attempt ${attempt}/3`);
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000 + (attempt * 5000)); // 10s, 15s, 20s
                    
                    const response = await fetch(WEBHOOK_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(data),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    console.log('Response status:', response.status);
                    console.log('Response ok:', response.ok);
                    
                    if (response.ok) {
                        console.log('‚úÖ Webhook sent successfully:', status);
                        try {
                            const responseText = await response.text();
                            console.log('Response body:', responseText);
                        } catch (e) {
                            console.log('Could not read response body');
                        }
                        return true;
                    } else {
                        console.error(`‚ùå Webhook failed with status ${response.status}`);
                        if (attempt === 3) {
                            try {
                                const errorText = await response.text();
                                console.error('Error response:', errorText);
                            } catch (e) {
                                console.error('Could not read error response');
                            }
                        }
                    }
                } catch (error) {
                    console.error(`‚ùå Webhook attempt ${attempt} failed:`, error.message);
                    
                    if (error.name === 'AbortError') {
                        console.error('Request timed out');
                    } else if (error.message.includes('network') || error.message.includes('fetch')) {
                        console.error('Network error - check internet connection');
                    }
                    
                    if (attempt === 3) {
                        console.error('All webhook attempts failed');
                        return false;
                    }
                    
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
                }
            }
            
            return false;
        }

        function updateMessage(text) {
            document.getElementById('message').textContent = text;
        }

        function checkGeofence(email,latitude,longitude){
            if(!geofence||!vehicleMarker)return;
            
            const jobMsg=document.getElementById('job-message');
            const point=turf.point([longitude,latitude]);
            const inside=turf.booleanPointInPolygon(point,geofence);
            
            if(jobTitle&&jobTitle!=='a job'){
                jobMsg.textContent=`Job: ${jobTitle}`;
                jobMsg.classList.remove('hidden');
            }

            if(inside&&!isInsideGeofence){
                console.log('üéØ Vehicle entered geofence');
                sendWebhook('inside',email,latitude,longitude);
                isInsideGeofence=true;
                updateMessage('Vehicle is at the job location!');
            }
            else if(!inside&&isInsideGeofence){
                console.log('üöó Vehicle left geofence');
                sendWebhook('outside',email,latitude,longitude);
                isInsideGeofence=false;
                updateMessage('Vehicle has left the job location!');
            }
            else if(!isInsideGeofence && !speechActive){
                updateMessage('Vehicle is on its way to the job location...');
            }
        }

        function speakText(text) {
            if (!speechActive || !text) return false;
            
            const normalizedText = text.toLowerCase().replace(/[^\w\s]/g, '').trim();
            const lastSpokenTime = recentlySpoken.get(normalizedText);
            const now = Date.now();
            
            if (lastSpokenTime && (now - lastSpokenTime) < SPEECH_COOLDOWN) {
                console.log('Skipping (too recent):', text.substring(0, 30));
                updateMessage(text);
                return false;
            }
            
            console.log('Speaking instruction:', text.substring(0, 50));
            recentlySpoken.set(normalizedText, now);
            updateMessage(text);
            
            try {
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = isMobileDevice ? 0.9 : 1.0;
                utterance.volume = 1.0;
                utterance.pitch = 1.0;
                
                utterance.onend = () => {
                    console.log('Finished speaking:', text.substring(0, 30));
                };
                
                utterance.onerror = (e) => {
                    console.warn('Speech error:', e.error);
                };
                
                window.speechSynthesis.speak(utterance);
                return true;
                
            } catch (error) {
                console.error('Speech error:', error);
                return false;
            }
        }

        function extractRouteSteps(route) {
            const steps = [];
            if (route && route[0] && route[0].legs) {
                route[0].legs.forEach(leg => {
                    if (leg.steps) {
                        leg.steps.forEach(step => {
                            if (step.maneuver && step.maneuver.instruction) {
                                steps.push({
                                    maneuver: step.maneuver,
                                    distance: step.distance,
                                    duration: step.duration
                                });
                            }
                        });
                    }
                });
            }
            return steps;
        }

        function calculateDistanceToNextStep(userLocation) {
            if (!currentRoute || !currentRoute[0] || !routeSteps || currentStepIndex >= routeSteps.length) {
                return null;
            }

            try {
                const currentStep = routeSteps[currentStepIndex];
                if (!currentStep || !currentStep.maneuver || !currentStep.maneuver.location) {
                    return null;
                }

                const stepLocation = currentStep.maneuver.location;
                const userPoint = turf.point([userLocation.lng, userLocation.lat]);
                const stepPoint = turf.point(stepLocation);
                
                const distanceMeters = turf.distance(userPoint, stepPoint, {units: 'meters'});
                const distanceFeet = distanceMeters * 3.28084;
                
                return {
                    distance: distanceFeet,
                    stepIndex: currentStepIndex,
                    instruction: currentStep.maneuver.instruction,
                    stepLocation: stepLocation
                };
            } catch (error) {
                console.warn('Error calculating distance:', error);
                return null;
            }
        }

        function updateDistanceInfo(distanceData) {
            const distanceInfo = document.getElementById('distance-info');
            // UPDATED: Only show distance info when within 1000 feet AND voice is active
            if (distanceData && speechActive && distanceData.distance <= 1000) {
                const distanceFeet = Math.round(distanceData.distance);
                distanceInfo.textContent = `Next turn in ${distanceFeet} feet`;
                distanceInfo.classList.remove('hidden');
            } else {
                distanceInfo.classList.add('hidden');
            }
        }

        function getCurrentInstruction() {
            console.log('Getting current instruction...');
            
            if (routeSteps && routeSteps.length > 0 && currentStepIndex < routeSteps.length) {
                const instruction = routeSteps[currentStepIndex]?.maneuver?.instruction;
                if (instruction && instruction.length > 5) {
                    console.log('Got instruction from routeSteps:', instruction);
                    return instruction;
                }
            }
            
            const stepSelectors = [
                '.mapbox-directions-step-active',
                '.mapbox-directions-step.active',
                '.mapbox-directions-step:first-child',
                '.mapboxgl-directions-step-active',
                '.mapboxgl-directions-step:first-child'
            ];
            
            for (const selector of stepSelectors) {
                const activeStep = document.querySelector(selector);
                if (activeStep) {
                    const instruction = extractInstructionFromStep(activeStep);
                    if (instruction && instruction.length > 5) {
                        console.log(`Got instruction from ${selector}:`, instruction);
                        return instruction;
                    }
                }
            }
            
            const allSteps = document.querySelectorAll('.mapbox-directions-step, .mapboxgl-directions-step');
            for (let i = 0; i < Math.min(3, allSteps.length); i++) {
                const step = allSteps[i];
                const instruction = extractInstructionFromStep(step);
                if (instruction && instruction.length > 5) {
                    console.log(`Got instruction from step ${i}:`, instruction);
                    return instruction;
                }
            }
            
            console.log('No instruction found');
            return null;
        }
        
        function extractInstructionFromStep(stepElement) {
            if (!stepElement) return null;
            
            const instructionSelectors = [
                '.mapbox-directions-step-maneuver-instruction',
                '.mapboxgl-directions-step-maneuver-instruction',
                '.mapbox-directions-instruction',
                '.mapbox-directions-step-instruction'
            ];
            
            for (const selector of instructionSelectors) {
                const instructionEl = stepElement.querySelector(selector);
                if (instructionEl) {
                    const text = instructionEl.textContent.trim();
                    if (text.length > 5 && !text.match(/^\d+\.?\d*\s*(km|mi|ft|miles?|minutes?|min|sec)/i)) {
                        return text;
                    }
                }
            }
            
            const text = stepElement.textContent.trim();
            const lines = text.split('\n').filter(line => line.trim().length > 5);
            for (const line of lines) {
                if (!line.match(/^\d+\.?\d*\s*(km|mi|ft|miles?|minutes?|min|sec)/i)) {
                    return line.trim();
                }
            }
            
            return null;
        }

        function startDistanceBasedNavigation() {
            if (!speechActive || !currentRoute) return;
            
            console.log('Starting distance-based navigation');
            
            routeSteps = extractRouteSteps(currentRoute);
            currentStepIndex = 0;
            
            console.log(`Route has ${routeSteps.length} steps`);
            
            if (distanceCheckInterval) {
                clearInterval(distanceCheckInterval);
            }
            
            distanceCheckInterval = setInterval(() => {
                if (!speechActive || !lastUserLocation) return;
                
                const distanceData = calculateDistanceToNextStep(lastUserLocation);
                if (!distanceData) return;
                
                updateDistanceInfo(distanceData);
                
                // UPDATED: Trigger speech at 1000 feet instead of 300
                if (distanceData.distance <= INSTRUCTION_TRIGGER_DISTANCE) {
                    speakText(distanceData.instruction);
                }
                
                if (distanceData.distance <= 50) {
                    const nextStepIndex = currentStepIndex + 1;
                    if (nextStepIndex < routeSteps.length) {
                        console.log(`Advancing to step ${nextStepIndex}`);
                        currentStepIndex = nextStepIndex;
                    }
                }
                
            }, 3000);
        }

        function attemptFirstInstruction(retryCount = 0) {
            const maxRetries = 8;
            
            if (retryCount >= maxRetries || !speechActive || firstInstructionSpoken) {
                if (retryCount >= maxRetries) {
                    console.log('Max retries reached for first instruction');
                    updateMessage('Route loaded, but no instructions available yet');
                }
                return;
            }
            
            console.log(`Attempting to get first instruction (attempt ${retryCount + 1})`);
            
            let instruction = null;
            
            if (routeSteps && routeSteps.length > 0) {
                instruction = routeSteps[0]?.maneuver?.instruction;
            }
            
            if (!instruction) {
                instruction = getCurrentInstruction();
            }
            
            if (instruction && instruction.length > 5) {
                console.log('Found first instruction:', instruction);
                firstInstructionSpoken = true;
                speakText(instruction);
                
                setTimeout(() => {
                    if (speechActive) {
                        startDistanceBasedNavigation();
                    }
                }, 2000);
            } else {
                setTimeout(() => {
                    attemptFirstInstruction(retryCount + 1);
                }, 2000);
            }
        }

        function stopTurnByTurnNavigation() {
            console.log('Stopping turn-by-turn navigation');
            
            if (distanceCheckInterval) {
                clearInterval(distanceCheckInterval);
                distanceCheckInterval = null;
            }
            
            currentStepIndex = 0;
            firstInstructionSpoken = false;
            
            document.getElementById('distance-info').classList.add('hidden');
        }

        function updateVoiceButtonState() {
            const btn = document.getElementById('voice-button');
            if (!btn) return;
            
            if (speechActive) {
                btn.textContent = 'üîá';
                btn.className = 'bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors';
            } else {
                btn.textContent = 'üó£Ô∏è';
                btn.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors';
            }
        }

        function toggleVoiceNavigation() {
            console.log('Voice button clicked');
            speechActive = !speechActive;
            
            if (speechActive) {
                recentlySpoken.clear();
                firstInstructionSpoken = false;
                currentStepIndex = 0;
                
                updateMessage('Voice navigation enabled');
                window.speechSynthesis.cancel();
                
                try {
                    const announcement = new SpeechSynthesisUtterance('Voice navigation enabled');
                    announcement.rate = isMobileDevice ? 0.9 : 1.0;
                    
                    announcement.onend = () => {
                        console.log('Announcement finished');
                        setTimeout(() => {
                            if (speechActive && directionsReady) {
                                console.log('Starting first instruction attempt');
                                attemptFirstInstruction();
                            } else if (speechActive) {
                                updateMessage('Waiting for route to load...');
                                attemptFirstInstruction();
                            }
                        }, 1000);
                    };
                    
                    announcement.onerror = (e) => {
                        console.error('Announcement error:', e);
                        setTimeout(() => {
                            if (speechActive) {
                                attemptFirstInstruction();
                            }
                        }, 2000);
                    };
                    
                    window.speechSynthesis.speak(announcement);
                    
                } catch (e) {
                    console.error('Error with announcement:', e);
                    setTimeout(() => {
                        if (speechActive) {
                            attemptFirstInstruction();
                        }
                    }, 1000);
                }
                
            } else {
                updateMessage('Voice navigation disabled');
                stopTurnByTurnNavigation();
                window.speechSynthesis.cancel();
            }
            
            updateVoiceButtonState();
        }

        function onGeolocationSuccess(pos){
            const coords = pos.coords;
            const userLoc = new mapboxgl.LngLat(coords.longitude, coords.latitude);
            lastUserLocation = userLoc;
            
            const userEmail = getUrlParams().email || 'testuser@example.com';

            if(!vehicleMarker){
                console.log('Creating vehicle marker');
                
                const car=document.createElement('div');
                car.innerHTML='üöó';
                car.style.fontSize='32px';
                vehicleMarker=new mapboxgl.Marker({element:car}).setLngLat(userLoc).addTo(map);
                document.getElementById('arrived-button').classList.remove('hidden');

                directions=new MapboxDirections({
                    accessToken:mapboxgl.accessToken,
                    unit:'imperial',
                    profile:'mapbox/driving',
                    controls:{inputs:false,instructions:true,profileSwitcher:false}
                });
                
                map.addControl(directions,'top-left');
                
                if(geofenceLocation) {
                    console.log('Setting destination:', geofenceLocation);
                    directions.setDestination([geofenceLocation.lng,geofenceLocation.lat]);
                }

                directions.on('route', (e) => {
                    console.log('Route calculated');
                    currentRoute = e.route;
                    routeSteps = extractRouteSteps(currentRoute);
                    
                    setTimeout(() => {
                        const hasSteps = document.querySelectorAll('.mapbox-directions-step, .mapboxgl-directions-step').length > 0;
                        console.log('Checking directions UI ready:', hasSteps, 'steps found:', document.querySelectorAll('.mapbox-directions-step, .mapboxgl-directions-step').length);
                        
                        directionsReady = true;
                        console.log(`Route ready with ${routeSteps.length} steps from route data`);
                        
                        if (speechActive && !firstInstructionSpoken) {
                            console.log('Voice active and route ready - attempting first instruction');
                            attemptFirstInstruction();
                        }
                        
                    }, 1500);
                });
            }
            
            vehicleMarker.setLngLat(userLoc);
            if(isInitialLoad){ 
                map.setCenter(userLoc); 
                isInitialLoad=false; 
            }
            
            if (directions) {
                directions.setOrigin([coords.longitude,coords.latitude]);
            }
            
            checkGeofence(userEmail,coords.latitude,coords.longitude);
        }

        function onGeolocationError(err){
            console.warn(`Geolocation error: ${err.message}`);
            updateMessage(`Location error: ${err.message}`);
        }

        function startGeolocationTracking() {
            console.log('Starting geolocation...');
            
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(onGeolocationSuccess, onGeolocationError, {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 5000
                });
            } else {
                updateMessage('Geolocation not supported');
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded');
            
            const voiceBtn = document.getElementById('voice-button');
            if (voiceBtn) {
                voiceBtn.addEventListener('click', toggleVoiceNavigation);
            }
        });

        window.onload = function(){
            console.log('Window loaded, initializing...');
            
            const {lat,lon,radius,job} = getUrlParams();
            jobTitle = job || 'Sample Job';
            const geofenceLat = lat || 40.7128;
            const geofenceLon = lon || -74.0060;
            const geofenceRadius = radius || 500;
            geofenceLocation = {lat: geofenceLat, lng: geofenceLon};
            
            console.log('Creating map...');
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: [geofenceLon, geofenceLat],
                zoom: 12
            });

            map.on('load', () => {
                console.log('Map loaded successfully');
                
                const center = [geofenceLon, geofenceLat];
                geofence = turf.circle(center, geofenceRadius, {steps: 64, units: 'feet'});
                map.addSource('geofence', {type: 'geojson', data: geofence});
                map.addLayer({
                    id: 'geofence-layer',
                    type: 'fill',
                    source: 'geofence',
                    paint: {'fill-color': '#007cbf', 'fill-opacity': 0.3}
                });
                new mapboxgl.Marker({color: '#007cbf'}).setLngLat(center).addTo(map);
                
                startGeolocationTracking();
            });

            map.on('error', (e) => {
                console.error('Map error:', e);
                updateMessage('Map failed to load');
            });

            document.getElementById('arrived-button').addEventListener('click', async () => {
                const userEmail = getUrlParams().email || 'testuser@example.com';
                const loc = vehicleMarker ? vehicleMarker.getLngLat() : {lat: 0, lng: 0};
                
                const button = document.getElementById('arrived-button');
                button.disabled = true;
                button.textContent = 'Completing...';
                button.className = 'bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md cursor-not-allowed';
                
                try {
                    console.log('üèÅ Attempting to send completion webhook...');
                    const webhookSuccess = await sendWebhook('complete', userEmail, loc.lat, loc.lng);
                    
                    if (webhookSuccess) {
                        updateMessage('Job Complete! Window will close in 3 seconds...');
                        
                        let countdown = 3;
                        const countdownInterval = setInterval(() => {
                            countdown--;
                            if (countdown > 0) {
                                updateMessage(`Job Complete! Window will close in ${countdown} seconds...`);
                            } else {
                                updateMessage('Job Complete! Closing now...');
                                clearInterval(countdownInterval);
                            }
                        }, 1000);
                        
                        setTimeout(() => {
                            console.log('Attempting to close window...');
                            
                            try {
                                window.close();
                            } catch (e) {
                                console.log('Standard window.close() failed:', e);
                            }
                            
                            try {
                                window.location.href = 'about:blank';
                            } catch (e) {
                                console.log('Redirect to about:blank failed:', e);
                            }
                            
                            updateMessage('Job Complete! Please close this window manually.');
                            
                        }, 3000);
                    } else {
                        updateMessage('Job marked complete, but webhook delivery failed. Please check network connection.');
                        button.disabled = false;
                        button.textContent = 'Retry Complete';
                        button.className = 'bg-orange-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-orange-600 transition-colors';
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error completing job:', error);
                    updateMessage('Error completing job. Check network and try again.');
                    
                    button.disabled = false;
                    button.textContent = 'Job Complete';
                    button.className = 'bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-green-600 transition-colors';
                }
            });

            updateVoiceButtonState();
            console.log('Initialization complete');
        };
    </script>
</body>
</html>
