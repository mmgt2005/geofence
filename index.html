<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geofence App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.js"></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.css" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { width: 100%; height: 100%; }
        .mapboxgl-ctrl-directions {
            top: 1rem; left: 1rem; right: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -2px rgba(0,0,0,0.1);
        }
        .mapbox-directions-step-active {
            background-color:#007cbf!important; color:white!important; font-weight:800;
        }
    </style>
</head>
<body class="flex flex-col h-screen">
    <div id="map" class="flex-1"></div>
    <div class="p-4 bg-gray-900 text-white shadow-lg z-10 flex flex-col sm:flex-row items-center justify-between rounded-t-xl">
        <div>
            <p id="message" class="text-xl font-bold mb-1">Please grant location permission to start...</p>
            <p id="job-message" class="text-xs text-gray-400 hidden"></p>
        </div>
        <div class="flex items-center space-x-2">
            <button id="arrived-button" class="bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-green-600 transition-colors hidden">Job Complete</button>
            <button id="voice-button" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-blue-600 transition-colors">üó£Ô∏è</button>
        </div>
    </div>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoibW1ndDIwMDUiLCJhIjoiY21laW4xY2dqMDQ1NDJpcHdqOW1hMDk3ZCJ9.aSTR_k5xhzGJNPPAVAFnlw';
        const WEBHOOK_URL = 'https://go.glideapps.com/api/container/plugin/webhook-trigger/LPCunXsYkOiRLSxXBhSH/5322e093-74bf-4793-92fa-ef5713bf8ab1';

        let map, vehicleMarker, geofence, directions;
        let isInsideGeofence = false, jobTitle, geofenceLocation;
        let isInitialLoad = true, speechActive = false;
        let directionsReady = false;
        let currentRoute = null;
        let currentStepIndex = 0;
        let instructionCheckInterval = null;

        // Initialize voice button immediately
        document.addEventListener('DOMContentLoaded', function() {
            const voiceBtn = document.getElementById('voice-button');
            if (voiceBtn) {
                voiceBtn.addEventListener('click', toggleVoiceNavigation);
                console.log('Voice button event listener attached');
            }
        });

        function initVoices() {
            let voices = speechSynthesis.getVoices();
            if (voices.length === 0) {
                speechSynthesis.onvoiceschanged = () => { voices = speechSynthesis.getVoices(); };
            }
        }
        initVoices();

        function getUrlParams() {
            const params = {};
            new URLSearchParams(window.location.search).forEach((value, key) => {
                params[key] = (key === 'lat' || key === 'lon' || key === 'radius') ? parseFloat(value) : value;
            });
            return params;
        }

        async function sendWebhook(status,email,latitude,longitude){
            if(!WEBHOOK_URL){console.warn("Webhook URL not configured.");return;}
            try{
                const data={status,latitude,longitude,email,job:jobTitle,timestamp:new Date().toISOString()};
                const r=await fetch(WEBHOOK_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(data)});
                if(!r.ok)console.error('Webhook failed',r.status);
            }catch(e){console.error('Error sending webhook:',e);}
        }

        function checkGeofence(email,latitude,longitude){
            if(!geofence||!vehicleMarker)return;
            const msg=document.getElementById('message');
            const jobMsg=document.getElementById('job-message');
            const point=turf.point([longitude,latitude]);
            const inside=turf.booleanPointInPolygon(point,geofence);
            if(jobTitle&&jobTitle!=='a job'){jobMsg.textContent=`Job: ${jobTitle}`;jobMsg.classList.remove('hidden');}
            else{jobMsg.classList.add('hidden');}

            if(inside&&!isInsideGeofence){sendWebhook('inside',email,latitude,longitude);isInsideGeofence=true;msg.textContent='Vehicle is at the job location!';}
            else if(!inside&&isInsideGeofence){sendWebhook('outside',email,latitude,longitude);isInsideGeofence=false;msg.textContent='Vehicle has left the job location!';}
            else if(!isInsideGeofence && !speechActive){msg.textContent='Vehicle is on its way to the job location...';}
        }

        function speakText(text){
            if(!text || !speechActive) {
                console.log('‚ùå Not speaking:', text, 'speechActive:', speechActive);
                return;
            }
            
            console.log('üîä SPEAKING:', text);
            
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();
            
            setTimeout(() => {
                const utter = new SpeechSynthesisUtterance(text);
                utter.lang = 'en-US';
                utter.rate = 0.9;
                utter.volume = 0.8;
                
                utter.onstart = () => console.log('üé§ Speech started:', text);
                utter.onend = () => console.log('üé§ Speech ended:', text);
                utter.onerror = (e) => console.log('‚ùå Speech error:', e);
                
                window.speechSynthesis.speak(utter);
            }, 100);
        }

        function updateVoiceButtonState() {
            const btn = document.getElementById('voice-button');
            if (!btn) return;
            
            if (!directionsReady) {
                btn.textContent = '‚è≥';
                btn.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'bg-green-500', 'hover:bg-green-600', 'ring-4', 'ring-green-400');
                btn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                btn.title = 'Waiting for route to load...';
            } else if (speechActive) {
                btn.textContent = 'üîá';
                btn.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'bg-gray-500', 'hover:bg-gray-600');
                btn.classList.add('bg-green-500', 'hover:bg-green-600', 'ring-4', 'ring-green-400');
                btn.title = 'Voice navigation ON - Click to disable';
            } else {
                btn.textContent = 'üó£Ô∏è';
                btn.classList.remove('bg-gray-500', 'hover:bg-gray-600', 'bg-green-500', 'hover:bg-green-600', 'ring-4', 'ring-green-400');
                btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                btn.title = 'Click to enable voice navigation';
            }
        }

        function getRouteInstructions() {
            console.log('üîç Getting route instructions...');
            
            // Method 1: Try multiple API approaches
            if (directions) {
                try {
                    const route = directions.getRoute();
                    if (route && route.legs && route.legs[0] && route.legs[0].steps) {
                        console.log('‚úÖ Found', route.legs[0].steps.length, 'steps from API');
                        return route.legs[0].steps;
                    }
                } catch (e) {
                    console.warn('‚ùå API method failed:', e);
                }
            }

            // Method 2: Only get instructions from DOM - don't return all at once
            const selectors = [
                '.mapbox-directions-step-maneuver-instruction',
                '.mapboxgl-directions-step-maneuver-instruction', 
                '.mapbox-directions-instruction',
                '[class*="instruction"]'
            ];

            for (const selector of selectors) {
                const elements = document.querySelectorAll(selector);
                
                if (elements.length > 0) {
                    const instructions = Array.from(elements).map((el, index) => {
                        const text = el.textContent.trim();
                        return { 
                            maneuver: { instruction: text },
                            stepIndex: index 
                        };
                    }).filter(inst => inst.maneuver.instruction.length > 0);
                    
                    if (instructions.length > 0) {
                        console.log('‚úÖ Found', instructions.length, 'instructions from DOM');
                        return instructions;
                    }
                }
            }

            console.log('‚ùå No instructions found by any method');
            return [];
        }

        function getCurrentInstruction() {
            console.log('üéØ === getCurrentInstruction called ===');
            
            // First, let's see what directions container exists
            const directionsContainer = document.querySelector('.mapboxgl-ctrl-directions');
            if (!directionsContainer) {
                console.log('‚ùå No directions container found at all');
                return null;
            }
            
            console.log('‚úÖ Directions container found');
            
            // Method 1: Look for step elements with multiple selectors
            const stepSelectors = [
                '.mapbox-directions-step',
                '.mapboxgl-directions-step',
                '[class*="directions-step"]'
            ];
            
            let allSteps = [];
            for (const selector of stepSelectors) {
                const steps = document.querySelectorAll(selector);
                if (steps.length > 0) {
                    allSteps = Array.from(steps);
                    console.log(`‚úÖ Found ${steps.length} steps using selector: ${selector}`);
                    break;
                }
            }
            
            if (allSteps.length === 0) {
                console.log('‚ùå No step elements found with any selector');
                
                // Method 2: Try to parse any text in the directions container
                const containerText = directionsContainer.innerText;
                console.log('üìÑ Directions container text:', containerText);
                
                // Look for instruction-like text
                const lines = containerText.split('\n').filter(line => {
                    const trimmed = line.trim();
                    return trimmed.length > 10 && 
                           !trimmed.match(/\d+\.?\d*\s*(km|mi|miles?|minutes?|min|hrs?|hours?)/i) &&
                           !trimmed.match(/^\d+\s*(km|mi)/) &&
                           trimmed.toLowerCase().includes('turn') ||
                           trimmed.toLowerCase().includes('head') ||
                           trimmed.toLowerCase().includes('continue') ||
                           trimmed.toLowerCase().includes('exit') ||
                           trimmed.toLowerCase().includes('merge');
                });
                
                if (lines.length > 0) {
                    console.log('‚úÖ Found instruction from text parsing:', lines[0]);
                    return lines[0].trim();
                }
                
                return null;
            }
            
            // Method 3: Look for active step
            let activeStep = null;
            const activeSelectors = [
                '.mapbox-directions-step-active',
                '.mapbox-directions-step.active',
                '.mapboxgl-directions-step-active'
            ];
            
            for (const selector of activeSelectors) {
                activeStep = document.querySelector(selector);
                if (activeStep) {
                    console.log(`‚úÖ Found active step using: ${selector}`);
                    break;
                }
            }
            
            if (!activeStep) {
                console.log('‚ö†Ô∏è No active step found, using first step');
                activeStep = allSteps[0];
            }
            
            if (activeStep) {
                // Try multiple instruction selectors within the step
                const instructionSelectors = [
                    '.mapbox-directions-step-maneuver-instruction',
                    '.mapboxgl-directions-step-maneuver-instruction',
                    '.mapbox-directions-instruction',
                    '[class*="instruction"]',
                    '.mapbox-directions-step-content'
                ];
                
                for (const selector of instructionSelectors) {
                    const instructionEl = activeStep.querySelector(selector);
                    if (instructionEl && instructionEl.textContent.trim()) {
                        const text = instructionEl.textContent.trim();
                        console.log(`‚úÖ Found instruction using ${selector}:`, text);
                        return text;
                    }
                }
                
                // Fallback: get any text from the step
                const stepText = activeStep.innerText.trim();
                if (stepText) {
                    // Parse out just the instruction part (remove distances/times)
                    const lines = stepText.split('\n').filter(line => {
                        const trimmed = line.trim();
                        return trimmed.length > 5 && 
                               !trimmed.match(/^\d+\.?\d*\s*(km|mi|miles?|minutes?|min)/i);
                    });
                    
                    if (lines.length > 0) {
                        console.log('‚úÖ Found instruction from step text:', lines[0]);
                        return lines[0].trim();
                    }
                }
            }
            
            console.log('‚ùå No instruction found at all');
            return null;
        }

        function startTurnByTurnNavigation() {
            if (!speechActive || !directionsReady) return;
            
            console.log('üöÄ === STARTING TURN-BY-TURN NAVIGATION ===');
            
            // Clear any existing monitoring
            if (instructionCheckInterval) {
                clearInterval(instructionCheckInterval);
                instructionCheckInterval = null;
            }
            
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();
            
            // Wait a bit longer for Mapbox to fully render the instructions
            console.log('‚è≥ Waiting for instructions to fully load...');
            
            let attempts = 0;
            const maxAttempts = 10;
            
            const tryToStartNavigation = () => {
                attempts++;
                console.log(`üîç Attempt ${attempts}/${maxAttempts} to get instructions...`);
                
                const instruction = getCurrentInstruction();
                
                if (instruction && instruction !== "No text found") {
                    console.log('‚úÖ Got instruction, starting navigation:', instruction);
                    document.getElementById('message').textContent = instruction;
                    speakText(instruction);
                    
                    // Start monitoring for changes
                    setupStepChangeMonitoring(instruction);
                    
                } else if (attempts < maxAttempts) {
                    console.log(`‚ùå No instruction found, trying again in 2 seconds... (attempt ${attempts})`);
                    setTimeout(tryToStartNavigation, 2000);
                    
                } else {
                    console.log('‚ùå Max attempts reached, using fallback');
                    const fallback = "Navigation started. Follow the route.";
                    document.getElementById('message').textContent = fallback;
                    speakText(fallback);
                }
            };
            
            // Start trying immediately, then keep trying
            tryToStartNavigation();
        }
        
        function setupStepChangeMonitoring(initialInstruction) {
            console.log('‚è∞ Setting up step change monitoring...');
            
            let lastSpokenInstruction = initialInstruction;
            let lastActiveStepIndex = -1;
            
            instructionCheckInterval = setInterval(() => {
                if (!speechActive) {
                    console.log('üõë Speech disabled, stopping monitoring');
                    if (instructionCheckInterval) {
                        clearInterval(instructionCheckInterval);
                        instructionCheckInterval = null;
                    }
                    return;
                }
                
                const activeStepEl = document.querySelector('.mapbox-directions-step-active') || 
                                   document.querySelector('.mapbox-directions-step.active');
                
                if (activeStepEl) {
                    const allSteps = document.querySelectorAll('.mapbox-directions-step');
                    const newActiveIndex = Array.from(allSteps).indexOf(activeStepEl);
                    
                    if (newActiveIndex !== -1 && newActiveIndex !== lastActiveStepIndex) {
                        console.log('üîÑ STEP CHANGED! From', lastActiveStepIndex, 'to', newActiveIndex);
                        
                        const newInstruction = getCurrentInstruction();
                        
                        if (newInstruction && newInstruction !== lastSpokenInstruction && newInstruction !== "No text found") {
                            console.log('üì¢ Speaking NEW instruction:', newInstruction);
                            document.getElementById('message').textContent = newInstruction;
                            speakText(newInstruction);
                            lastSpokenInstruction = newInstruction;
                            lastActiveStepIndex = newActiveIndex;
                        }
                    }
                }
            }, 3000);
        }

        function stopTurnByTurnNavigation() {
            console.log('üõë Stopping turn-by-turn navigation');
            
            if (instructionCheckInterval) {
                clearInterval(instructionCheckInterval);
                instructionCheckInterval = null;
            }
            
            window.speechSynthesis.cancel();
        }

        function toggleVoiceNavigation() {
            console.log('üéØ Voice button clicked, current state:', speechActive);
            
            speechActive = !speechActive;
            const msg = document.getElementById('message');
            
            if (speechActive) {
                if (!directionsReady) {
                    msg.textContent = 'Waiting for route to load...';
                    speakText('Please wait for the route to load.');
                } else {
                    msg.textContent = 'Voice navigation enabled';
                    speakText('Voice navigation enabled');
                    
                    // Start navigation after a brief delay
                    setTimeout(() => {
                        startTurnByTurnNavigation();
                    }, 1500);
                }
            } else {
                msg.textContent = 'Voice navigation disabled';
                stopTurnByTurnNavigation();
            }
            
            updateVoiceButtonState();
        }

        function onGeolocationSuccess(pos){
            const coords=pos.coords;
            const userLoc=new mapboxgl.LngLat(coords.longitude,coords.latitude);
            const userEmail=getUrlParams().email||'testuser@example.com';

            if(!vehicleMarker){
                const car=document.createElement('div');
                car.innerHTML='üöó';
                car.style.fontSize='32px';
                vehicleMarker=new mapboxgl.Marker({element:car}).setLngLat(userLoc).addTo(map);
                document.getElementById('arrived-button').classList.remove('hidden');

                directions=new MapboxDirections({
                    accessToken:mapboxgl.accessToken,
                    unit:'imperial',
                    profile:'mapbox/driving',
                    controls:{inputs:false,instructions:true,profileSwitcher:false}
                });
                
                map.addControl(directions,'top-left');
                map.dragPan.disable();
                map.on('mousedown',()=>{
                    if (!speechActive) {
                        document.getElementById('message').textContent="Map movement is disabled for this navigation.";
                    }
                });
                
                if(geofenceLocation) {
                    console.log('üéØ Setting destination:', geofenceLocation);
                    directions.setDestination([geofenceLocation.lng,geofenceLocation.lat]);
                }

                directions.on('route', (e) => {
                    console.log('‚úÖ Route calculated successfully');
                    console.log('üìä Route data:', e.route);
                    currentRoute = e.route;
                    
                    // Wait longer for UI to render and try multiple times
                    let attempts = 0;
                    const maxAttempts = 10;
                    
                    const checkDirectionsReady = () => {
                        attempts++;
                        console.log(`üîç Checking directions readiness (attempt ${attempts}/${maxAttempts})`);
                        
                        const hasSteps = document.querySelectorAll('.mapbox-directions-step').length > 0;
                        const hasInstructions = document.querySelector('.mapbox-directions-step-maneuver-instruction') || 
                                              document.querySelector('[class*="instruction"]');
                        const hasDirectionsContainer = document.querySelector('.mapboxgl-ctrl-directions');
                        
                        console.log('üìä Readiness check:', {
                            hasSteps,
                            hasInstructions: !!hasInstructions,
                            hasDirectionsContainer: !!hasDirectionsContainer,
                            attempt: attempts
                        });
                        
                        if (hasDirectionsContainer && (hasSteps || hasInstructions)) {
                            directionsReady = true;
                            updateVoiceButtonState();
                            console.log('üéâ Directions UI ready, voice navigation available');
                            
                            // Test instruction retrieval immediately
                            console.log('üß™ Testing instruction retrieval...');
                            const testInstructions = getRouteInstructions();
                            console.log('üß™ Test result:', testInstructions.length, 'instructions found');
                            
                            // If voice was enabled while waiting, start navigation
                            if (speechActive) {
                                console.log('üöÄ Voice was already enabled, starting navigation...');
                                setTimeout(() => {
                                    startTurnByTurnNavigation();
                                }, 1000);
                            }
                        } else if (attempts < maxAttempts) {
                            console.log('‚è≥ Not ready yet, trying again in 2 seconds...');
                            setTimeout(checkDirectionsReady, 2000);
                        } else {
                            console.log('‚ö†Ô∏è Max attempts reached, marking as ready anyway');
                            directionsReady = true;
                            updateVoiceButtonState();
                        }
                    };
                    
                    // Start checking after initial delay
                    setTimeout(checkDirectionsReady, 3000);
                });

                directions.on('error', (e) => {
                    console.error('‚ùå Directions error:', e);
                    document.getElementById('message').textContent = 'Error calculating route. Please check your connection.';
                });

                directions.on('clear', () => {
                    console.log('üßπ Route cleared');
                    directionsReady = false;
                    currentRoute = null;
                    stopTurnByTurnNavigation();
                    updateVoiceButtonState();
                });
            }
            
            vehicleMarker.setLngLat(userLoc);
            if(isInitialLoad){ 
                map.setCenter(userLoc); 
                isInitialLoad=false; 
            }
            
            if (directions) {
                directions.setOrigin([coords.longitude,coords.latitude]);
            }
            
            checkGeofence(userEmail,coords.latitude,coords.longitude);
        }

        function onGeolocationError(err){
            const msg = document.getElementById('message');
            console.warn(`Geolocation error(${err.code}): ${err.message}`);
            
            switch(err.code) {
                case err.PERMISSION_DENIED:
                    msg.textContent = "Location access denied. Please enable location services.";
                    break;
                case err.POSITION_UNAVAILABLE:
                    msg.textContent = "Location information unavailable. Retrying...";
                    retryGeolocation();
                    break;
                case err.TIMEOUT:
                    msg.textContent = "Location request timed out. Retrying with better settings...";
                    retryGeolocation();
                    break;
                default:
                    msg.textContent = `Geolocation error: ${err.message}`;
                    break;
            }
        }

        let geolocationRetries = 0;
        const maxGeolocationRetries = 3;

        function retryGeolocation() {
            if (geolocationRetries < maxGeolocationRetries) {
                geolocationRetries++;
                document.getElementById('message').textContent = `Retrying location (${geolocationRetries}/${maxGeolocationRetries})...`;
                
                setTimeout(() => {
                    startGeolocationTracking();
                }, 2000);
            } else {
                document.getElementById('message').textContent = "Unable to get location. Please check your GPS and try refreshing.";
            }
        }

        function startGeolocationTracking() {
            const options = {
                enableHighAccuracy: geolocationRetries > 0 ? false : true,
                timeout: geolocationRetries === 0 ? 10000 : 15000,
                maximumAge: geolocationRetries > 1 ? 60000 : 0
            };

            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(onGeolocationSuccess, onGeolocationError, options);
            } else {
                document.getElementById('message').textContent = 'Geolocation not supported by this browser.';
            }
        }

        window.onload=function(){
            const {lat,lon,radius,job}=getUrlParams();
            jobTitle=job||'Sample Job Title';
            const geofenceLat=lat||40.7128, geofenceLon=lon||-74.0060, geofenceRadius=radius||500;
            geofenceLocation={lat:geofenceLat,lng:geofenceLon};
            const jobMsg=document.getElementById('job-message');
            if(jobTitle&&jobTitle!=='a job'){ 
                jobMsg.textContent=`Job: ${jobTitle}`; 
                jobMsg.classList.remove('hidden'); 
            }

            map=new mapboxgl.Map({
                container:'map',
                style:'mapbox://styles/mapbox/streets-v12',
                center:[geofenceLon,geofenceLat],
                zoom:12
            });

            map.on('load',()=>{
                const center=[geofenceLon,geofenceLat];
                geofence=turf.circle(center,geofenceRadius,{steps:64,units:'feet'});
                map.addSource('geofence',{type:'geojson',data:geofence});
                map.addLayer({
                    id:'geofence-layer',
                    type:'fill',
                    source:'geofence',
                    paint:{'fill-color':'#007cbf','fill-opacity':0.3}
                });
                new mapboxgl.Marker({color:'#007cbf'}).setLngLat(center).addTo(map);
                startGeolocationTracking();
            });

            document.getElementById('arrived-button').addEventListener('click',()=>{
                const userEmail=getUrlParams().email||'testuser@example.com';
                const loc=vehicleMarker ? vehicleMarker.getLngLat() : {lat: 0, lng: 0};
                sendWebhook('complete',userEmail,loc.lat,loc.lng);
                document.getElementById('message').textContent='Job Complete!';
                setTimeout(()=>{ window.close(); },1000);
            });

            // Ensure voice button is connected (backup)
            const voiceBtn = document.getElementById('voice-button');
            if (voiceBtn && !voiceBtn.onclick) {
                voiceBtn.addEventListener('click', toggleVoiceNavigation);
            }

            updateVoiceButtonState();
            console.log('üöÄ App initialized');
        }
    </script>
</body>
</html>
