<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geofence App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.10.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.js"></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.0/mapbox-gl-directions.css" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { width: 100%; height: 100%; }
        .mapboxgl-ctrl-directions {
            top: 1rem; left: 1rem; right: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1),0 2px 4px -2px rgba(0,0,0,0.1);
        }
        .mapbox-directions-step-active {
            background-color:#007cbf!important; color:white!important; font-weight:800;
        }
    </style>
</head>
<body class="flex flex-col h-screen">
    <div id="map" class="flex-1"></div>
    <div class="p-4 bg-gray-900 text-white shadow-lg z-10 flex flex-col sm:flex-row items-center justify-between rounded-t-xl">
        <div class="flex-1 mr-12">
            <p id="message" class="text-xl font-bold mb-1">Please grant location permission to start...</p>
            <p id="distance-info" class="text-xs text-green-400 hidden mb-1"></p>
            <p id="job-message" class="text-xs text-gray-400 hidden"></p>
        </div>
        <div class="flex items-center space-x-3 mt-2 sm:mt-0">
            <button id="arrived-button" class="bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-green-600 transition-colors hidden">Job Complete</button>
            <button id="voice-button" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-blue-600 transition-colors">üó£Ô∏è</button>
        </div>
    </div>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoibW1ndDIwMDUiLCJhIjoiY21laW4xY2dqMDQ1NDJpcHdqOW1hMDk3ZCJ9.aSTR_k5xhzGJNPPAVAFnlw';
        const WEBHOOK_URL = 'https://go.glideapps.com/api/container/plugin/webhook-trigger/LPCunXsYkOiRLSxXBhSH/5322e093-74bf-4793-92fa-ef5713bf8ab1';

        let map, vehicleMarker, geofence, directions;
        let isInsideGeofence = false, jobTitle, geofenceLocation;
        let isInitialLoad = true, speechActive = false;
        let directionsReady = false;
        let currentRoute = null;
        let instructionCheckInterval = null;
        
        // Enhanced instruction tracking with distance-based triggering
        let lastSpokenInstructionHash = '';  
        let isCurrentlySpeaking = false;
        let pendingGeofenceUpdate = null;
        let spokenInstructions = new Set(); 
        let lastActiveStepElement = null;
        let firstInstructionSpoken = false;
        let lastSpokenText = '';
        let speechQueue = [];
        let isProcessingQueue = false;
        let speechStartTime = 0;
        let lastSpeechEndTime = 0;
        
        // Mobile-specific speech handling - COMPLETELY isolated and protected
        let isMobileDevice = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let mobileInstructionsSpoken = new Map(); // Track with full text and timestamps
        let mobileSpeechLocked = false;
        let mobileSpeechTimeout = null;
        
        // New variables for distance-based instruction triggering
        const INSTRUCTION_TRIGGER_DISTANCE = 300; // feet
        let routeSteps = [];
        let currentStepIndex = 0;
        let lastUserLocation = null;
        let distanceCheckInterval = null;
        let nextInstructionTriggered = new Set();
        let recentInstructions = new Map(); // Track recent instructions with timestamps

        // Initialize voice button immediately
        document.addEventListener('DOMContentLoaded', function() {
            const voiceBtn = document.getElementById('voice-button');
            if (voiceBtn) {
                voiceBtn.addEventListener('click', toggleVoiceNavigation);
                console.log('Voice button event listener attached');
            }
        });

        function initVoices() {
            let voices = speechSynthesis.getVoices();
            if (voices.length === 0) {
                speechSynthesis.onvoiceschanged = () => { voices = speechSynthesis.getVoices(); };
            }
        }
        initVoices();

        function getUrlParams() {
            const params = {};
            new URLSearchParams(window.location.search).forEach((value, key) => {
                params[key] = (key === 'lat' || key === 'lon' || key === 'radius') ? parseFloat(value) : value;
            });
            return params;
        }

        async function sendWebhook(status,email,latitude,longitude){
            if(!WEBHOOK_URL){console.warn("Webhook URL not configured.");return;}
            try{
                const data={status,latitude,longitude,email,job:jobTitle,timestamp:new Date().toISOString()};
                const r=await fetch(WEBHOOK_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(data)});
                if(!r.ok)console.error('Webhook failed',r.status);
            }catch(e){console.error('Error sending webhook:',e);}
        }

        function updateMessage(text, priority = 'normal', temporary = false) {
            const msg = document.getElementById('message');
            
            // Don't interrupt voice navigation messages unless high priority
            if (speechActive && priority !== 'high' && isCurrentlySpeaking) {
                console.log('Message update queued (voice navigation active):', text);
                pendingGeofenceUpdate = text;
                return;
            }
            
            msg.textContent = text;
            
            // Clear any pending updates if we're setting a high priority message
            if (priority === 'high') {
                pendingGeofenceUpdate = null;
            }
            
            // If temporary, revert after delay (only if not speaking)
            if (temporary && !speechActive) {
                setTimeout(() => {
                    if (!speechActive && !isCurrentlySpeaking) {
                        msg.textContent = 'Vehicle is on its way to the job location...';
                    }
                }, 5000); // Extended from 3000 to 5000ms
            }
        }

        function checkGeofence(email,latitude,longitude){
            if(!geofence||!vehicleMarker)return;
            
            const jobMsg=document.getElementById('job-message');
            const point=turf.point([longitude,latitude]);
            const inside=turf.booleanPointInPolygon(point,geofence);
            
            if(jobTitle&&jobTitle!=='a job'){
                jobMsg.textContent=`Job: ${jobTitle}`;
                jobMsg.classList.remove('hidden');
            } else {
                jobMsg.classList.add('hidden');
            }

            if(inside&&!isInsideGeofence){
                sendWebhook('inside',email,latitude,longitude);
                isInsideGeofence=true;
                updateMessage('Vehicle is at the job location!', 'high');
            }
            else if(!inside&&isInsideGeofence){
                sendWebhook('outside',email,latitude,longitude);
                isInsideGeofence=false;
                updateMessage('Vehicle has left the job location!', 'high');
            }
            else if(!isInsideGeofence && !speechActive && !isCurrentlySpeaking){
                updateMessage('Vehicle is on its way to the job location...');
            }
        }

        // Enhanced distance calculation and step tracking
        function calculateDistanceToNextStep(userLocation) {
            if (!currentRoute || !currentRoute[0] || !currentRoute[0].legs || currentStepIndex >= routeSteps.length) {
                return null;
            }

            try {
                const currentStep = routeSteps[currentStepIndex];
                if (!currentStep || !currentStep.maneuver || !currentStep.maneuver.location) {
                    return null;
                }

                const stepLocation = currentStep.maneuver.location;
                const userPoint = turf.point([userLocation.lng, userLocation.lat]);
                const stepPoint = turf.point(stepLocation);
                
                // Calculate distance in feet
                const distanceMeters = turf.distance(userPoint, stepPoint, {units: 'meters'});
                const distanceFeet = distanceMeters * 3.28084;
                
                return {
                    distance: distanceFeet,
                    stepIndex: currentStepIndex,
                    instruction: currentStep.maneuver.instruction,
                    stepLocation: stepLocation
                };
            } catch (error) {
                console.warn('Error calculating distance to next step:', error);
                return null;
            }
        }

        function updateDistanceInfo(distanceData) {
            const distanceInfo = document.getElementById('distance-info');
            if (distanceData && speechActive) {
                const distanceFeet = Math.round(distanceData.distance);
                distanceInfo.textContent = `Next turn in ${distanceFeet} feet`;
                distanceInfo.classList.remove('hidden');
            } else {
                distanceInfo.classList.add('hidden');
            }
        }

        function extractRouteSteps(route) {
            const steps = [];
            if (route && route[0] && route[0].legs) {
                route[0].legs.forEach(leg => {
                    if (leg.steps) {
                        leg.steps.forEach(step => {
                            if (step.maneuver && step.maneuver.instruction) {
                                steps.push({
                                    maneuver: step.maneuver,
                                    distance: step.distance,
                                    duration: step.duration
                                });
                            }
                        });
                    }
                });
            }
            return steps;
        }

        // Create a hash of instruction content to detect real changes
        function createInstructionHash(text) {
            if (!text) return '';
            const normalized = text.toLowerCase().trim().replace(/\s+/g, ' ');
            let hash = 0;
            for (let i = 0; i < normalized.length; i++) {
                const char = normalized.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        // ULTRA-PROTECTED mobile speech - no interruptions allowed
        function mobileSpeechOnly(text) {
            if (!isMobileDevice || !speechActive || !text) return false;
            
            const cleanText = text.trim();
            const now = Date.now();
            
            // NEVER allow duplicate instructions on mobile
            if (mobileInstructionsSpoken.has(cleanText)) {
                const lastTime = mobileInstructionsSpoken.get(cleanText);
                console.log(`MOBILE BLOCKED: Already spoken "${cleanText}" at ${new Date(lastTime).toLocaleTimeString()}`);
                return false;
            }
            
            // NEVER interrupt ongoing mobile speech
            if (mobileSpeechLocked) {
                console.log('MOBILE BLOCKED: Speech locked, cannot interrupt');
                return false;
            }
            
            console.log(`MOBILE SPEAKING: "${cleanText}"`);
            
            // Lock speech immediately and mark as spoken
            mobileSpeechLocked = true;
            mobileInstructionsSpoken.set(cleanText, now);
            
            // Force stop any existing speech
            try {
                window.speechSynthesis.cancel();
            } catch (e) {
                console.log('Error cancelling speech:', e);
            }
            
            // Clear any existing timeout
            if (mobileSpeechTimeout) {
                clearTimeout(mobileSpeechTimeout);
                mobileSpeechTimeout = null;
            }
            
            // Emergency unlock after 20 seconds in case something goes wrong
            mobileSpeechTimeout = setTimeout(() => {
                console.log('MOBILE: Emergency speech unlock after 20 seconds');
                mobileSpeechLocked = false;
                mobileSpeechTimeout = null;
            }, 20000);
            
            // Wait 2 seconds before attempting speech to ensure engine is ready
            setTimeout(() => {
                if (!speechActive || !mobileSpeechLocked) {
                    mobileSpeechLocked = false;
                    return;
                }
                
                try {
                    const utterance = new SpeechSynthesisUtterance(cleanText);
                    utterance.lang = 'en-US';
                    utterance.rate = 0.5; // Even slower
                    utterance.volume = 1.0;
                    utterance.pitch = 1.0;
                    
                    // Use the most basic voice to avoid complications
                    const voices = window.speechSynthesis.getVoices();
                    if (voices && voices.length > 0) {
                        // Try to find a simple English voice
                        const simpleVoice = voices.find(v => 
                            v.lang.includes('en') && !v.name.includes('Enhanced')
                        ) || voices[0];
                        utterance.voice = simpleVoice;
                    }
                    
                    let speechComplete = false;
                    
                    utterance.onstart = function() {
                        console.log('MOBILE: Speech started successfully');
                    };
                    
                    utterance.onend = function() {
                        if (!speechComplete) {
                            speechComplete = true;
                            console.log('MOBILE: Speech completed normally');
                            mobileSpeechLocked = false;
                            if (mobileSpeechTimeout) {
                                clearTimeout(mobileSpeechTimeout);
                                mobileSpeechTimeout = null;
                            }
                        }
                    };
                    
                    utterance.onerror = function(event) {
                        if (!speechComplete) {
                            speechComplete = true;
                            console.log('MOBILE: Speech error occurred:', event.error);
                            mobileSpeechLocked = false;
                            if (mobileSpeechTimeout) {
                                clearTimeout(mobileSpeechTimeout);
                                mobileSpeechTimeout = null;
                            }
                            
                            // Only remove from spoken list if it was a real error (not interruption)
                            if (event.error === 'network' || event.error === 'synthesis-failed') {
                                mobileInstructionsSpoken.delete(cleanText);
                            }
                        }
                    };
                    
                    // Attempt to speak
                    window.speechSynthesis.speak(utterance);
                    
                } catch (error) {
                    console.error('MOBILE: Critical speech error:', error);
                    mobileSpeechLocked = false;
                    mobileInstructionsSpoken.delete(cleanText);
                    if (mobileSpeechTimeout) {
                        clearTimeout(mobileSpeechTimeout);
                        mobileSpeechTimeout = null;
                    }
                }
                
            }, 2000); // Wait 2 full seconds
            
            return true;
        }

        // Speech routing function - mobile gets special treatment
        function addToSpeechQueue(text, priority = 'normal') {
            if (!text || !speechActive) return;
            
            // Mobile devices ONLY use the protected speech function
            if (isMobileDevice) {
                mobileSpeechOnly(text);
                return;
            }
            
            // Desktop queue management (unchanged - working perfectly)
            const now = Date.now();
            const normalizedText = text.toLowerCase().trim();
            
            if (recentInstructions.has(normalizedText)) {
                const lastSpoken = recentInstructions.get(normalizedText);
                if (now - lastSpoken < 1000) {
                    console.log('DESKTOP BLOCKED: Recently spoken instruction -', text);
                    return;
                }
            }
            
            if (now - lastSpeechEndTime < 500) {
                console.log('DESKTOP BLOCKED: Speech cooldown period active -', text);
                return;
            }
            
            const speech = {
                text: text,
                priority: priority,
                hash: createInstructionHash(text),
                timestamp: now
            };
            
            const existingInQueue = speechQueue.find(item => 
                item.hash === speech.hash || item.text.toLowerCase().trim() === normalizedText
            );
            
            if (existingInQueue) {
                console.log('DESKTOP BLOCKED: Duplicate already in queue -', text);
                return;
            }
            
            recentInstructions.set(normalizedText, now);
            
            for (const [key, timestamp] of recentInstructions.entries()) {
                if (now - timestamp > 30000) {
                    recentInstructions.delete(key);
                }
            }
            
            if (priority === 'high') {
                speechQueue.unshift(speech);
            } else {
                speechQueue.push(speech);
            }
            
            processSpeechQueue();
        }

        function processSpeechQueue() {
            // Skip queue processing for mobile - handled directly
            if (isMobileDevice) return;
            
            if (isProcessingQueue || speechQueue.length === 0 || !speechActive) return;
            
            const now = Date.now();
            
            if (now - lastSpeechEndTime < 500) {
                console.log('DESKTOP BLOCKED: Speech delay not met');
                setTimeout(processSpeechQueue, 500);
                return;
            }
            
            isProcessingQueue = true;
            const speech = speechQueue.shift();
            
            if (!speech) {
                isProcessingQueue = false;
                return;
            }
            
            speakText(speech.text, speech.hash);
        }

        function speakText(text, instructionHash = null){
            // Mobile devices ONLY use the ultra-protected speech
            if (isMobileDevice) {
                mobileSpeechOnly(text);
                return;
            }
            
            // Desktop speech handling (unchanged - working perfectly)
            if(!text || !speechActive) {
                isProcessingQueue = false;
                return;
            }
            
            const now = Date.now();
            const hash = instructionHash || createInstructionHash(text);
            const trimmedText = text.trim().toLowerCase();
            
            if (spokenInstructions.has(hash)) {
                console.log('DESKTOP BLOCKED: Hash already spoken -', text);
                isProcessingQueue = false;
                setTimeout(processSpeechQueue, 500);
                return;
            }
            
            if (lastSpokenText === trimmedText && (now - speechStartTime) < 1000) {
                console.log('DESKTOP BLOCKED: Same text recently spoken -', text);
                isProcessingQueue = false;
                setTimeout(processSpeechQueue, 500);
                return;
            }
            
            if (window.speechSynthesis.speaking) {
                console.log('Cancelling ongoing speech for new instruction');
                window.speechSynthesis.cancel();
                
                setTimeout(() => {
                    if (speechActive) {
                        speakTextNow(text, hash);
                    }
                }, 300);
                return;
            }
            
            speakTextNow(text, hash);
        }
        
        function speakTextNow(text, instructionHash) {
            // This function is only for desktop now
            if (isMobileDevice) return;
            
            console.log('DESKTOP SPEAKING:', text);
            
            const now = Date.now();
            speechStartTime = now;
            isCurrentlySpeaking = true;
            
            lastSpokenText = text.trim().toLowerCase();
            if (!firstInstructionSpoken) {
                firstInstructionSpoken = true;
            }
            
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'en-US';
            utter.rate = 0.8;
            utter.volume = 0.9;
            utter.pitch = 1.0;
            
            const voices = speechSynthesis.getVoices();
            const preferredVoice = voices.find(voice => 
                voice.lang.startsWith('en') && (voice.name.includes('Google') || voice.name.includes('Microsoft'))
            ) || voices.find(voice => voice.lang.startsWith('en'));
            
            if (preferredVoice) {
                utter.voice = preferredVoice;
            }
            
            utter.onstart = () => {
                console.log('DESKTOP: Speech started:', text);
                isCurrentlySpeaking = true;
                lastSpokenInstructionHash = instructionHash;
                spokenInstructions.add(instructionHash);
                speechStartTime = Date.now();
            };
            
            utter.onend = () => {
                console.log('DESKTOP: Speech ended:', text);
                isCurrentlySpeaking = false;
                isProcessingQueue = false;
                lastSpeechEndTime = Date.now();
                
                setTimeout(() => {
                    if (speechActive && speechQueue.length > 0) {
                        processSpeechQueue();
                    }
                }, 500);
                
                if (pendingGeofenceUpdate && !speechActive) {
                    setTimeout(() => {
                        if (!isCurrentlySpeaking) {
                            updateMessage(pendingGeofenceUpdate);
                            pendingGeofenceUpdate = null;
                        }
                    }, 1000);
                }
            };
            
            utter.onerror = (e) => {
                console.log('DESKTOP: Speech error:', e.error);
                isCurrentlySpeaking = false;
                isProcessingQueue = false;
                lastSpeechEndTime = Date.now();
                
                if (e.error !== 'interrupted') {
                    setTimeout(() => {
                        if (speechActive && speechQueue.length > 0) {
                            processSpeechQueue();
                        }
                    }, 1000);
                }
            };
            
            window.speechSynthesis.speak(utter);
        }

        function updateVoiceButtonState() {
            const btn = document.getElementById('voice-button');
            if (!btn) return;
            
            if (!directionsReady) {
                btn.textContent = '‚è≥';
                btn.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'bg-green-500', 'hover:bg-green-600', 'ring-4', 'ring-green-400');
                btn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                btn.title = 'Waiting for route to load...';
            } else if (speechActive) {
                btn.textContent = 'üîá';
                btn.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'bg-gray-500', 'hover:bg-gray-600');
                btn.classList.add('bg-green-500', 'hover:bg-green-600', 'ring-4', 'ring-green-400');
                btn.title = 'Voice navigation ON - Click to disable';
            } else {
                btn.textContent = 'üó£Ô∏è';
                btn.classList.remove('bg-gray-500', 'hover:bg-gray-600', 'bg-green-500', 'hover:bg-green-600', 'ring-4', 'ring-green-400');
                btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                btn.title = 'Click to enable voice navigation';
            }
        }

        // Enhanced distance-based instruction monitoring with FULL mobile protection
        function startDistanceBasedNavigation() {
            if (!speechActive || !currentRoute) return;
            
            console.log('Starting distance-based navigation');
            
            // Extract route steps
            routeSteps = extractRouteSteps(currentRoute);
            currentStepIndex = 0;
            nextInstructionTriggered.clear();
            
            // CLEAR all mobile speech history when starting new route
            if (isMobileDevice) {
                mobileInstructionsSpoken.clear();
                mobileSpeechLocked = false;
                if (mobileSpeechTimeout) {
                    clearTimeout(mobileSpeechTimeout);
                    mobileSpeechTimeout = null;
                }
            }
            
            console.log(`Route has ${routeSteps.length} steps`);
            
            // Clear existing monitoring
            if (distanceCheckInterval) {
                clearInterval(distanceCheckInterval);
            }
            
            // Start monitoring user distance to next instruction
            distanceCheckInterval = setInterval(() => {
                if (!speechActive || !lastUserLocation) return;
                
                // COMPLETELY SKIP distance checking if mobile is speaking
                if (isMobileDevice && mobileSpeechLocked) {
                    console.log('MOBILE: Skipping ALL distance monitoring - speech locked');
                    return;
                }
                
                const distanceData = calculateDistanceToNextStep(lastUserLocation);
                if (!distanceData) return;
                
                // Update distance display (but don't interfere with speech)
                updateDistanceInfo(distanceData);
                
                const stepKey = `${currentStepIndex}_${distanceData.instruction}`;
                
                // Trigger instruction at 300 feet
                if (distanceData.distance <= INSTRUCTION_TRIGGER_DISTANCE && 
                    !nextInstructionTriggered.has(stepKey)) {
                    
                    console.log(`Triggering instruction at ${Math.round(distanceData.distance)} feet: ${distanceData.instruction}`);
                    
                    nextInstructionTriggered.add(stepKey);
                    
                    // Update message but don't interfere with speech on mobile
                    if (!isMobileDevice || !mobileSpeechLocked) {
                        updateMessage(distanceData.instruction, 'high');
                    }
                    
                    // Speech handling
                    if (isMobileDevice) {
                        mobileSpeechOnly(distanceData.instruction);
                    } else {
                        addToSpeechQueue(distanceData.instruction, 'high');
                    }
                }
                
                // Advance to next step when very close (within 50 feet)
                if (distanceData.distance <= 50) {
                    const nextStepIndex = currentStepIndex + 1;
                    if (nextStepIndex < routeSteps.length) {
                        console.log(`Advancing to step ${nextStepIndex}`);
                        currentStepIndex = nextStepIndex;
                    }
                }
                
            }, isMobileDevice ? 5000 : 2000); // Much slower checking on mobile
        }

        function getCurrentInstruction() {
            const activeStep = document.querySelector('.mapbox-directions-step-active') || 
                              document.querySelector('.mapbox-directions-step.active');
            
            if (activeStep) {
                const instruction = extractInstructionFromStep(activeStep);
                if (instruction && instruction.length > 8) {
                    return instruction;
                }
            }
            
            const allSteps = document.querySelectorAll('.mapbox-directions-step');
            for (let i = 0; i < Math.min(3, allSteps.length); i++) {
                const step = allSteps[i];
                const instruction = extractInstructionFromStep(step);
                if (instruction && instruction.length > 8) {
                    return instruction;
                }
            }
            
            return null;
        }
        
        function extractInstructionFromStep(stepElement) {
            if (!stepElement) return null;
            
            const instructionSelectors = [
                '.mapbox-directions-step-maneuver-instruction',
                '.mapboxgl-directions-step-maneuver-instruction',
                '.mapbox-directions-instruction',
                '.mapbox-directions-step-content'
            ];
            
            for (const selector of instructionSelectors) {
                const instructionEl = stepElement.querySelector(selector);
                if (instructionEl) {
                    const text = instructionEl.textContent.trim();
                    if (text.length > 8 && !text.match(/^\d+\.?\d*\s*(km|mi|ft|miles?|minutes?|min)/i)) {
                        return text;
                    }
                }
            }
            
            const stepText = stepElement.textContent.trim();
            const sentences = stepText.split('.').map(s => s.trim()).filter(s => s.length > 0);
            
            for (const sentence of sentences) {
                if (sentence.match(/^\d+\.?\d*\s*(km|mi|miles?|minutes?|min|ft|feet)/i)) {
                    continue;
                }
                
                if (sentence.match(/\b(drive|turn|continue|keep|take|merge|exit|head|go|proceed|follow|bear|stay)\b/i) && 
                    sentence.length > 10) {
                    return sentence + '.';
                }
            }
            
            return null;
        }

        function startTurnByTurnNavigation() {
            if (!speechActive || !directionsReady) return;
            
            console.log('Starting enhanced turn-by-turn navigation');
            
            // Reset all tracking variables
            spokenInstructions.clear();
            speechQueue = [];
            isProcessingQueue = false;
            lastSpokenInstructionHash = '';
            lastActiveStepElement = null;
            isCurrentlySpeaking = false;
            firstInstructionSpoken = false;
            lastSpokenText = '';
            nextInstructionTriggered.clear();
            
            // COMPLETELY reset mobile speech system
            if (isMobileDevice) {
                mobileInstructionsSpoken.clear();
                mobileSpeechLocked = false;
                if (mobileSpeechTimeout) {
                    clearTimeout(mobileSpeechTimeout);
                    mobileSpeechTimeout = null;
                }
            }
            
            // Clear existing monitoring
            if (instructionCheckInterval) {
                clearInterval(instructionCheckInterval);
                instructionCheckInterval = null;
            }
            
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();
            
            // Start with the first instruction - but handle mobile specially
            setTimeout(() => {
                const firstInstruction = getCurrentInstruction();
                if (firstInstruction && firstInstruction.length > 8) {
                    console.log('Speaking first instruction:', firstInstruction);
                    
                    if (isMobileDevice) {
                        // For mobile, speak the first instruction with our protected function
                        updateMessage(firstInstruction, 'high');
                        mobileSpeechOnly(firstInstruction);
                    } else {
                        // Desktop uses queue system
                        updateMessage(firstInstruction, 'high');
                        addToSpeechQueue(firstInstruction, 'high');
                    }
                }
                
                // Start distance-based navigation
                setTimeout(() => {
                    startDistanceBasedNavigation();
                }, isMobileDevice ? 5000 : 2000); // Wait longer on mobile
                
            }, 1000);
        }

        function stopTurnByTurnNavigation() {
            console.log('Stopping turn-by-turn navigation');
            
            // Clear all intervals
            if (instructionCheckInterval) {
                clearInterval(instructionCheckInterval);
                instructionCheckInterval = null;
            }
            
            if (distanceCheckInterval) {
                clearInterval(distanceCheckInterval);
                distanceCheckInterval = null;
            }
            
            // Cancel speech and reset variables
            window.speechSynthesis.cancel();
            isCurrentlySpeaking = false;
            isProcessingQueue = false;
            speechQueue = [];
            spokenInstructions.clear();
            lastSpokenInstructionHash = '';
            lastActiveStepElement = null;
            pendingGeofenceUpdate = null;
            firstInstructionSpoken = false;
            lastSpokenText = '';
            nextInstructionTriggered.clear();
            currentStepIndex = 0;
            recentInstructions.clear();
            speechStartTime = 0;
            lastSpeechEndTime = 0;
            
            // COMPLETELY reset mobile speech system
            if (isMobileDevice) {
                mobileInstructionsSpoken.clear();
                mobileSpeechLocked = false;
                if (mobileSpeechTimeout) {
                    clearTimeout(mobileSpeechTimeout);
                    mobileSpeechTimeout = null;
                }
            }
            
            // Hide distance info
            document.getElementById('distance-info').classList.add('hidden');
        }
            
            // Reset mobile-specific variables
            mobileSpokenInstructions.clear();
            mobileCurrentlySpeaking = false;
            mobileLastSpeechTime = 0;
            
            // Hide distance info
            document.getElementById('distance-info').classList.add('hidden');
        }

        function toggleVoiceNavigation() {
            console.log('Voice button clicked, current state:', speechActive);
            
            speechActive = !speechActive;
            
            if (speechActive) {
                if (!directionsReady) {
                    updateMessage('Waiting for route to load...', 'high');
                    addToSpeechQueue('Please wait for the route to load.');
                } else {
                    updateMessage('Voice navigation enabled', 'high');
                    addToSpeechQueue('Voice navigation enabled');
                    
                    setTimeout(() => {
                        startTurnByTurnNavigation();
                    }, 2000);
                }
            } else {
                updateMessage('Voice navigation disabled', 'high', true);
                stopTurnByTurnNavigation();
            }
            
            updateVoiceButtonState();
        }

        // Enhanced location tracking with better timing
        let lastLocationUpdate = 0;
        const LOCATION_UPDATE_INTERVAL = 1000; // Reduced interval for better responsiveness

        function onGeolocationSuccess(pos){
            const now = Date.now();
            const coords = pos.coords;
            const userLoc = new mapboxgl.LngLat(coords.longitude, coords.latitude);
            
            // Update last user location for distance calculations
            lastUserLocation = userLoc;
            
            // Throttle UI updates when voice is active and speaking
            if (speechActive && isCurrentlySpeaking && (now - lastLocationUpdate) < LOCATION_UPDATE_INTERVAL) {
                return;
            }
            
            lastLocationUpdate = now;
            const userEmail = getUrlParams().email || 'testuser@example.com';

            if(!vehicleMarker){
                const car=document.createElement('div');
                car.innerHTML='üöó';
                car.style.fontSize='32px';
                vehicleMarker=new mapboxgl.Marker({element:car}).setLngLat(userLoc).addTo(map);
                document.getElementById('arrived-button').classList.remove('hidden');

                directions=new MapboxDirections({
                    accessToken:mapboxgl.accessToken,
                    unit:'imperial',
                    profile:'mapbox/driving',
                    controls:{inputs:false,instructions:true,profileSwitcher:false}
                });
                
                map.addControl(directions,'top-left');
                map.dragPan.disable();
                map.on('mousedown',()=>{
                    if (!speechActive) {
                        updateMessage("Map movement is disabled for this navigation.", 'normal', true);
                    }
                });
                
                if(geofenceLocation) {
                    console.log('Setting destination:', geofenceLocation);
                    directions.setDestination([geofenceLocation.lng,geofenceLocation.lat]);
                }

                directions.on('route', (e) => {
                    console.log('Route calculated successfully');
                    currentRoute = e.route;
                    
                    let attempts = 0;
                    const maxAttempts = 10;
                    
                    const checkDirectionsReady = () => {
                        attempts++;
                        console.log(`Checking directions readiness (attempt ${attempts}/${maxAttempts})`);
                        
                        const hasDirectionsContainer = document.querySelector('.mapboxgl-ctrl-directions');
                        const hasSteps = document.querySelectorAll('.mapbox-directions-step').length > 0;
                        
                        if (hasDirectionsContainer && hasSteps) {
                            directionsReady = true;
                            updateVoiceButtonState();
                            console.log('Directions UI ready');
                            
                            // Extract route steps for distance-based navigation
                            routeSteps = extractRouteSteps(currentRoute);
                            console.log(`Route loaded with ${routeSteps.length} steps`);
                            
                            if (speechActive) {
                                console.log('Voice was already enabled, starting navigation...');
                                setTimeout(startTurnByTurnNavigation, 1000);
                            }
                        } else if (attempts < maxAttempts) {
                            setTimeout(checkDirectionsReady, 2000);
                        } else {
                            console.log('Max attempts reached, marking as ready');
                            directionsReady = true;
                            updateVoiceButtonState();
                        }
                    };
                    
                    setTimeout(checkDirectionsReady, 1500);
                });

                directions.on('error', (e) => {
                    console.error('Directions error:', e);
                    updateMessage('Error calculating route. Please check your connection.', 'high');
                });

                directions.on('clear', () => {
                    console.log('Route cleared');
                    directionsReady = false;
                    currentRoute = null;
                    routeSteps = [];
                    stopTurnByTurnNavigation();
                    updateVoiceButtonState();
                });
            }
            
            vehicleMarker.setLngLat(userLoc);
            if(isInitialLoad){ 
                map.setCenter(userLoc); 
                isInitialLoad=false; 
            }
            
            if (directions) {
                directions.setOrigin([coords.longitude,coords.latitude]);
            }
            
            // Check geofence with reduced frequency during speech
            if (!isCurrentlySpeaking || (now - lastLocationUpdate) >= LOCATION_UPDATE_INTERVAL) {
                checkGeofence(userEmail,coords.latitude,coords.longitude);
            }
        }

        function onGeolocationError(err){
            console.warn(`Geolocation error(${err.code}): ${err.message}`);
            
            switch(err.code) {
                case err.PERMISSION_DENIED:
                    updateMessage("Location access denied. Please enable location services.", 'high');
                    break;
                case err.POSITION_UNAVAILABLE:
                    updateMessage("Location information unavailable. Retrying...", 'high');
                    retryGeolocation();
                    break;
                case err.TIMEOUT:
                    updateMessage("Location request timed out. Retrying with better settings...", 'high');
                    retryGeolocation();
                    break;
                default:
                    updateMessage(`Geolocation error: ${err.message}`, 'high');
                    break;
            }
        }

        let geolocationRetries = 0;
        const maxGeolocationRetries = 3;

        function retryGeolocation() {
            if (geolocationRetries < maxGeolocationRetries) {
                geolocationRetries++;
                updateMessage(`Retrying location (${geolocationRetries}/${maxGeolocationRetries})...`, 'high');
                
                setTimeout(() => {
                    startGeolocationTracking();
                }, 2000);
            } else {
                updateMessage("Unable to get location. Please check your GPS and try refreshing.", 'high');
            }
        }

        function startGeolocationTracking() {
            const options = {
                enableHighAccuracy: geolocationRetries > 0 ? false : true,
                timeout: geolocationRetries === 0 ? 10000 : 15000,
                maximumAge: geolocationRetries > 1 ? 60000 : 2000 // Reduced for better real-time tracking
            };

            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(onGeolocationSuccess, onGeolocationError, options);
            } else {
                updateMessage('Geolocation not supported by this browser.', 'high');
            }
        }

        window.onload=function(){
            const {lat,lon,radius,job}=getUrlParams();
            jobTitle=job||'Sample Job Title';
            const geofenceLat=lat||40.7128, geofenceLon=lon||-74.0060, geofenceRadius=radius||500;
            geofenceLocation={lat:geofenceLat,lng:geofenceLon};
            const jobMsg=document.getElementById('job-message');
            if(jobTitle&&jobTitle!=='a job'){ 
                jobMsg.textContent=`Job: ${jobTitle}`; 
                jobMsg.classList.remove('hidden'); 
            }

            map=new mapboxgl.Map({
                container:'map',
                style:'mapbox://styles/mapbox/streets-v12',
                center:[geofenceLon,geofenceLat],
                zoom:12
            });

            map.on('load',()=>{
                const center=[geofenceLon,geofenceLat];
                geofence=turf.circle(center,geofenceRadius,{steps:64,units:'feet'});
                map.addSource('geofence',{type:'geojson',data:geofence});
                map.addLayer({
                    id:'geofence-layer',
                    type:'fill',
                    source:'geofence',
                    paint:{'fill-color':'#007cbf','fill-opacity':0.3}
                });
                new mapboxgl.Marker({color:'#007cbf'}).setLngLat(center).addTo(map);
                startGeolocationTracking();
            });

            document.getElementById('arrived-button').addEventListener('click',()=>{
                const userEmail=getUrlParams().email||'testuser@example.com';
                const loc=vehicleMarker ? vehicleMarker.getLngLat() : {lat: 0, lng: 0};
                sendWebhook('complete',userEmail,loc.lat,loc.lng);
                updateMessage('Job Complete!', 'high');
                setTimeout(()=>{ window.close(); },1000);
            });

            const voiceBtn = document.getElementById('voice-button');
            if (voiceBtn && !voiceBtn.onclick) {
                voiceBtn.addEventListener('click', toggleVoiceNavigation);
            }

            updateVoiceButtonState();
            console.log('App initialized with enhanced voice navigation');
        }
    </script>
</body>
</html>
